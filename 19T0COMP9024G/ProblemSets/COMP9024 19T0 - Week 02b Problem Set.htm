<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>COMP9024 19T0 - Week 02b Problem Set</title>
<link rel='stylesheet' type='text/css' href='./course.css'><script language="JavaScript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=AM_HTMLorMML">
function changeText(el, newText) {
  // Safari work around
  if (el.innerText)
    el.innerText = newText;
  else if (el.firstChild && el.firstChild.nodeValue)
    el.firstChild.nodeValue = newText;
}
function toggleVisible(elid) {
  el1 = document.getElementById(elid);
  el2 = document.getElementById(elid+"a");
  if (el1.style.display == "") {
     el1.style.display = "none";
     changeText(el2,"show answer");
  }
  else {
     el1.style.display = "";
     changeText(el2,"hide answer");
  }
}
</script></head>
<body>
<div align='center'>
<table width='100%' border='0'>
<tr valign='top'>
<td align='left' width='25%'>
  <span class='tiny'><a href="http://www.cse.unsw.edu.au/~cs9024/19T0/index.php">COMP9024 19T0</a></span>
</td>
<td align='center' width='50%'>
  <span class='heading'>Week 02b Problem Set</span><br>
  <span class='subheading'>Analysis of Algorithms</span>
</td>
<td align='right' width='25%'>
  <span class='tiny'><a href="http://www.handbook.unsw.edu.au/postgraduate/courses/2019/COMP9024.html">Data Structures and Algorithms</a></span>
</td>
</table>
</div><p style='text-align:center;font-size:75%'><a href='/~cs9024/19t0/probs/prob02b/index.php?view=qo'>[Show with no answers]</a> &nbsp; <a href='/~cs9024/19t0/probs/prob02b/index.php?view=all'>[Show with all answers]</a></div>

<ol>

<br>
<li>(Big-Oh Notation)
<ol type="a">
<li>
<p>
Show that `sum_(i=1)^n i^2` is O(<i>n</i><sup>3</sup>)
</p>
<li>
<p>
Show that if <i>p(n)</i> is any polynomial in <i>n</i>, then <i>log p(n)</i> is O(<i>log n</i>)
</p>
<li>
<p>
Show that `sum_(i=1)^n log i` is O(<i>n log n</i>)
</p>
<li>
<p>
Show that `sum_(i=1)^n (i)/(2^i)` is O(1)
</p>
</ol>
<p><small>[<a id="q1a" href="##" onclick="toggleVisible('q1')">show answer</a>]</small></p>
<div id="q1" style="color:#000099;display:none">
<ol type="a">
<li> <b>corrected</b>: `1^2+2^2+...+n^2 = (n(n+1)(2n+1))/6`, which is `O(n^3)`
<li> Let `p(n) = a_kn^k+a_(k-1)n^(k-1)+...+a_1n+a_0`. Then `p(n) < max{|a_k|,|a_(k-1)|,...,|a_0|}*(k+1)*n^k`. Hence, `log p(n) < k*log max{|a_k|,|a_(k-1)|,...,|a_0|}*(k+1)*n`.
<p>Since <i>k</i> and <i>a<sub>k</sub>,&hellip;,a<sub>0</sub></i> are constants, it follows that log <i>p(n)</i> is O(<i>log n</i>).</p>
<li>`sum_(i=1)^(n)log i <= sum_(i=1)^(n)log n = n*log n`, which is O(<i>n log n</i>)
<li>Let `S = sum_(i=1)^n(i)/(2^i)`. Then `S = sum_(i=1)^n(1)/(2^i)+sum_(i=1)^n(i-1)/(2^i) = sum_(i=1)^n (1)/(2^i)+sum_(i=1)^(n-1)(i)/(2^(i+1)) < 1+1/2S`. Therefore, `S<2`. Consequently, `sum_(i=1)^n(i)/(2^i)` is O(1).
<br>Note: it is easy to see that `sum_(i=1)^n1/(2^i)<1` from the fact that `sum_(i=1)^(oo)1/2^i=1`.
</ol>
</div>

<br>
<li>(Counting primitive operations)

<p>The following algorithm
<ul>
<li> takes a sorted array A[1..<i>n</i>] of characters
   <li> and outputs, in reverse order, all 2-letter words &nu;&omega; such that &nu;&le;&omega;.
</ul>
</p>
<p>
			  &nbsp;&nbsp;<b>for all</b> i=<i>n</i> down to 1 <b>do</b>
<br>
										   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>for all</b> j=<i>n</i> down to <i>i</i> <b>do</b>
<br>
																					   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print "A[i]A[j]"
<br>
			  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>end for</b>
<br>
			  &nbsp;&nbsp;<b>end for</b>
</p>
<p>Count the number of primitive operations (evaluating an expression, indexing into an array). What is the time complexity of this algorithm in big-Oh notation?</p>

<p><small>[<a id="q2a" href="##" onclick="toggleVisible('q2')">show answer</a>]</small></p>
<div id="q2" style="color:#000099;display:none">
<table style="border-top:1px solid #000099;border-bottom:1px solid #000099;color:#000099">
						  <tr><td colspan="4">Statement</td><td>&nbsp;&nbsp;<td># primitive operations</td></tr>
<tr></tr>
<tr></tr>
<tr><td colspan="4"><b>for all</b> i=<i>n</i> down to 1 <b>do</b></td><td>&nbsp;&nbsp;<td>n+(n+1)</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td colspan="3"><b>for all</b> j=<i>n</i> down to <i>i</i> <b>do</b></td><td></td><td>3+5+&hellip;+(2n+1) = n(n+2)</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td colspan="2">print "A[<i>i</i>]A[<i>j</i>]"</td><td></td><td>(1+2+&hellip;+n)&middot;2 = n(n+1)</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td colspan="3"><b>end for</b></td><td></td></tr>
<tr><td colspan="4"><b>end for</b></td><td></td></tr>
</table>
 <p>Total: 2n<sup>2</sup>+5n+1, which is O(n<sup>2</sup>)</p>
</div>

<br>
<br>
<li>(Algorithms and complexity)

<p>Develop an algorithm to determine if a character array of length <i>n</i> encodes a <i>palindrome</i>, that is, which reads the same forward and backward. For example, "racecar" is a palindrome.</p>
<ol type="a">
<li><p>Write the algorithm in pseudocode.</p>
<li><p>Analyse the time complexity of your algorithm.</p>
<li><p>Implement your algorithm in C. Your program should accept a single command line argument and check whether it is a palindrome. Examples of the program executing are</p>
<pre class="command_line">
<kbd class="shell">./palindrome racecar</kbd>
yes
<kbd class="shell">./palindrome reviewer</kbd>
no
</pre>
<p>
<i>Hint:</i> You may use the standard library function <tt>strlen(char[])</tt>, defined in <tt>&lt;string.h&gt;</tt>, which computes the length of a string (without counting its terminating <tt>'\0'</tt>-character).
</p>
</ol>
<p>
 
<div style="background-color:lightyellow;">
<i>We have created a script that can automatically test your program. To run this test you can execute the </i><tt>dryrun</tt><i> program that corresponds to the problem set and week, i.e. prob04 for this week. It expects to find a program named </i><tt>palindrome.c</tt><i> in the current directory. You can use dryrun as follows:</i></p>
<pre class="command_line">
<kbd class="shell">~cs9024/bin/dryrun prob02b</kbd>
</pre>
</div>

<p><small>[<a id="q3a" href="##" onclick="toggleVisible('q3')">show answer</a>]</small></p>
<div id="q3" style="color:#000099;display:none">
<pre class="pseudocode">
isPalindrome(A):
   <b>Input</b>  array A[0..n-1] of chars
   <b>Output</b> true if A palindrome, false otherwise

   i=0, j=n-1
   <b>while</b> i&lt;j <b>do</b>
      <b>if</b> A[i]&ne;A[j] <b>then</b>
         <b>return</b> false
      <b>end if</b>
      i=i+1, j=j-1
   <b>end while</b>
   <b>return</b> true
</pre>
<p>Time complexity analysis: There are at most `|__n/2__|` iterations of the loop, and the operations inside the loop are O(1). Hence, this algorithm takes O(<i>n</i>) time.</p>
<pre class="answer">
#include &lt;stdio.h&gt;
#include &ltstring.h&gt;

int isPalindrome(char A[], int len) {
   int i = 0;
   int j = len-1;

   while (i < j) {
      if (A[i] != A[j])
	 return 0;
      i++;
      j--;
   }
   return 1;
}

int main(int argc, char *argv[]) {
   if (argc == 2) {
      if (isPalindrome(argv[1], strlen(argv[1])))
	 printf("yes\n");
      else
	 printf("no\n");
   }
   return 0;
}
</pre>
</div>

<br>
<br>
<li>(Algorithms and complexity)

<p>
Let <i>p(x)</i> = a<sub>n</sub>x<sup>n</sup>+a<sub>n-1</sub>x<sup>n-1</sup>+&hellip;+a<sub>1</sub>x+a<sub>0</sub> be a polynomial of degree n. Design an O(<i>n</i>)-time algorithm for computing <i>p(x)</i>.
</p>
<p>
<i>Hint:</i> Assume that the coefficients a<sub>i</sub> are stored in an array A[0..n].

<p><small>[<a id="q4a" href="##" onclick="toggleVisible('q4')">show answer</a>]</small></p>
<div id="q4" style="color:#000099;display:none">
Rewriting <i>p(x)</i> as <i>(&hellip;((a<sub>n</sub>x+a<sub>n-1</sub>)&middot;x+a<sub>n-2</sub>)&middot;x+&hellip;+a<sub>1</sub>)&middot;x+a<sub>0</sub></i> leads to the following algorithm:
<pre class="pseudocode">
p=A[n]
<b>for all</b> i=n-1 down to 0 <b>do</b>
   p=p&middot;x+A[i]
<b>end for</b>
</pre>
<p>This is obviously O(n).</p>
</div>

<br>
<br>
<li>(Algorithms and complexity)

<p>
A vector V is called <i>sparse</i> if most of its elements are 0. In order to store sparse vectors efficiently, we can use a list L to store only its non-zero elements. Specifically, for each non-zero element <i>V[i]</i>, we store an index-value pair <i>(i,V[i])</i> in L.
</p>
<p>For example, the 8-dimensional vector <i>V</i>=(2.3,0,0,0,-5.61,0,0,1.8) can be stored in a list L of size 3, namely L[0]=(0,2.3), L[1]=(4,-5.61) and L[2]=(7,1.8). We call L the <i>compact form</i> of V.</p>
<p>
Describe an efficient algorithm for adding two sparse vectors <i>V<sub>1</sub></i> and <i>V<sub>2</sub></i> of equal dimension but given in compact form. The result should be in compact form too, of course. What is the time complexity of your algorithm depending on the sizes <i>m</i> and <i>n</i> of the compact forms of <i>V<sub>1</sub></i> and <i>V<sub>2</sub></i>, respectively?
<p>
<i>Hint:</i> The sum of two vectors <i>V<sub>1</sub></i> and <i>V<sub>2</sub></i> is defined as usual, e.g. (2.3,-0.1,0,0,1.7,0,0,0) + (0,3.14,0,0,-1.7,0,0,-1.8) = (2.3,3.04,0,0,0,0,0,-1.8).
</p>

<p><small>[<a id="q5a" href="##" onclick="toggleVisible('q5')">show answer</a>]</small></p>
<div id="q5" style="color:#000099;display:none">
In the algorithm below, <tt>L[i].x</tt> denotes the first component (the index) of a pair L[i], and <tt>L[i].v</tt> denotes its second component (the value).
<pre class="pseudocode">
VectorSum(L<sub>1</sub>,L<sub>2</sub>):
   <b>Input</b>  compact forms L<sub>1</sub> of length m and L<sub>2</sub> of length n
   <b>Output</b> compact form of L<sub>1</sub>+L<sub>2</sub>

   i=0, j=0, k=0
   <b>while</b> i&leq;m-1 &and; j&leq;n-1 <b>do</b>
      <del><b>if</b> L<sub>1</sub>[i].x=L<sub>2</sub>[i].x <b>then</b>       // found index with entries in both vectors</del>
      <b>if</b> L<sub>1</sub>[i].x=L<sub>2</sub>[j].x <b>then</b>       // found index with entries in both vectors
         <b>if</b> L<sub>1</sub>[i].v&ne;-L<sub>2</sub>[j].v <b>then</b>   // only add if the values don't add up to 0
            L<sub>3</sub>[k]=(L<sub>1</sub>[i].x, L<sub>1</sub>[i].v+L<sub>2</sub>[j].v)
            i=i+1, j=j+1, k=k+1
         <b>end if</b>
      <b>else if</b> L<sub>1</sub>[i].x&lt;L<sub>2</sub>[j].x <b>then</b>  // copy an entry from L<sub>1</sub>
         L<sub>3</sub>[k]=(L<sub>1</sub>[i].x,L<sub>1</sub>[i].v)
         i=i+1, k=k+1
      <b>else</b>
         L<sub>3</sub>[k]=(L<sub>2</sub>[j].x,L<sub>2</sub>[j].v)    // copy an entry from L<sub>2</sub>
         j=j+1, k=k+1
      <b>end if</b>
   <b>end while</b>
   <b>while</b> i&lt;m-1 <b>do</b>                  // copy the remaining pairs of L<sub>1</sub>, if any
      L<sub>3</sub>[k]=(L<sub>1</sub>[i].x,L<sub>1</sub>[i].v)
      i=i+1, k=k+1
   <b>end while</b>      
   <b>while</b> j&lt;n-1 <b>do</b>                  // copy the remaining pairs of L<sub>2</sub>, if any
      L<sub>3</sub>[k]=(L<sub>2</sub>[j].x,L<sub>2</sub>[j].v)
      j=j+1, k=k+1
   <b>end while</b>
</pre>
<p>
Time complexity analysis: Adding a pair to L<sub>3</sub> takes O(1) time. At most <i>m</i>+<i>n</i> pairs from L<sub>1</sub> and L<sub>2</sub> are added. Therefore, the time complexity is O(<i>m</i>+<i>n</i>).
</p>
</div>

<br>
<li><b>Challenge Exercise</b>
<p>Suppose that you are given two stacks of non-negeative integers A and B and a target threshold <i>k</i> &geq; 0. Your task is to determine the maximum number of elements that you can pop from A and B so that the sum of these elements does not exceed <i>k</i>.</p>
<p>Example:
<br>
<img src="Pic/stacks.png" style="width:100px;" align="middle"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <table style="display:inline"><tr><td>&nbsp;</td></tr><tr><td>&nbsp;</td></tr><tr><td>Maximum number of elements that can</td></tr><tr><td>be popped without exceeding <i>k</i> = 10 is 4:</td></tr></table> &nbsp; &nbsp; <img src="Pic/stacks-solution.png" style="width:100px;" align="middle">
</p>
<p>If k = 7, then the answer would be 3 (the top element of A and the top two elements of B).</p>
<ol type="a">
<li> Write an algorithm (in pseudocode) to determine this maximum for any given stacks A and B and threshold <i>k</i>. As usual, the only operations you can perform on the stacks are pop() and push().
You <i>are</i> permitted to use a third "helper" stack but no other aggregate data structure.
<li><p>Determine the time complexity of your algorithm depending on the sizes <i>m</i> and <i>n</i> of input stacks A and B.</p>
</ol>

<i>Hints:</i>
<ul>
<li> A so-called greedy algorithm would simply take the smaller of the two elements currently on top of the stacks and continue to do so as long as you haven't exceeded the threshold. This won't work in general for this problem.
<li> Your algorithm only needs to determine the number of elements that can maximally be popped without exceeding the given <i>k</i>. You do not have to return the numbers themselves nor their sum. Also you do not need to restore the contents of the two stacks; they can be left in any state you wish.
</ul>

<p><small>[<a id="q6a" href="##" onclick="toggleVisible('q6')">show answer</a>]</small></p>
<div id="q6" style="color:#000099;display:none">
<pre class="pseudocode">
MaxElementsToPop(A,B,k):
   <b>Input</b>  stacks A and B, target threshold k&geq;0
   <b>Output</b> maximum number of elements that can be popped from A and B
          so that their sum does not exceed k

   sum=0, count=0, create empty stack C
   <b>while</b> sum&leq;k &and; stack A not empty <b>do</b>     // Phase 1: Determine how many elements can be popped just from A
      v=pop(A), push(v,C)                 //          and push those onto the helper stack C
      sum=sum+v, count=count+1
   <b>end while</b>
   <b>if</b> sum&gt;k <b>then</b>                          // exceeded k?
      v=pop(C), sum=sum-v, count=count-1  //   then subtract last element that's been popped off A
   <b>end if</b>
   best=count                             // best you can do with elements from A only

   <b>while</b> stack B not empty <b>do</b>
      v=pop(B), sum=sum+v, count=count+1  // Phase 2: add one element from B at a time
      <b>while</b> sum&gt;k &and; stack C not empty <b>do</b>     // and whenever threshold is exceeded
         v=pop(C), sum=sum-v, count=count-1  //   subtract more elements originally from A (now in C)
      <b>end while</b>                              //   to get back below threshold
      <b>if</b> sum&leq;k &and; count&gt;best <b>then</b>
         best=count                       // update each time you got a better score
      <b>end if</b>
   <b>end while</b>
   <b>return</b> best
</pre>
<p>
Time complexity analysis: In phase 1, the worst case is when all <i>m</i> elements in stack A need to be visited, for a maximum of <i>m</i>+1 pop and <i>m</i> push operations. In phase 2, the worst case is when all elements have to be taken from both B and C, for a maximum of <i>m</i>+<i>n</i> pop operations. Assuming that push and pop take constant time, the overall complexity is O(m+n). This makes it a linear-time solution.
</p>
</div>

</ol>
</body>
</html>
