<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>COMP9024 19T0 - Week 06b Problem Set</title>
<link rel='stylesheet' type='text/css' href='./course.css'><script language="JavaScript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=AM_HTMLorMML">
function changeText(el, newText) {
  // Safari work around
  if (el.innerText)
    el.innerText = newText;
  else if (el.firstChild && el.firstChild.nodeValue)
    el.firstChild.nodeValue = newText;
}
function toggleVisible(elid) {
  el1 = document.getElementById(elid);
  el2 = document.getElementById(elid+"a");
  if (el1.style.display == "") {
     el1.style.display = "none";
     changeText(el2,"show answer");
  }
  else {
     el1.style.display = "";
     changeText(el2,"hide answer");
  }
}
</script></head>
<body>
<div align='center'>
<table width='100%' border='0'>
<tr valign='top'>
<td align='left' width='25%'>
  <span class='tiny'><a href="http://www.cse.unsw.edu.au/~cs9024/19T0/index.php">COMP9024 19T0</a></span>
</td>
<td align='center' width='50%'>
  <span class='heading'>Week 06b Problem Set</span><br>
  <span class='subheading'>Random Numbers, Real Balanced Trees</span>
</td>
<td align='right' width='25%'>
  <span class='tiny'><a href="http://www.handbook.unsw.edu.au/postgraduate/courses/2019/COMP9024.html">Data Structures and Algorithms</a></span>
</td>
</table>
</div><p style='text-align:center;font-size:75%'><a href='/~cs9024/19t0/probs/prob06b/index.php?view=qo'>[Show with no answers]</a> &nbsp; <a href='/~cs9024/19t0/probs/prob06b/index.php?view=all'>[Show with all answers]</a></div>

<ol>
<br>
<li> (Random numbers)

<ol type="a">
 <li> <p>A program that simulates the tosses of a coin is as follows:
 <pre>
#define NTOSSES 20
srandom(time(NULL));
int i, count = 0;
for (i=0; i&lt;NTOSSES; i++) {
   int toss = random() % 2;     // toss = 0 or 1
   if (toss == 0) {
      putchar('H');
      count++;
   } else {
      putchar('T');
   }
}
printf(&quot;\n%d heads, %d tails\n&quot;, count, NTOSSES-count);
</pre>
</p>
Sample output is:
 <pre>
HHTTTTHHTTTHHTHHHHHH
12 heads, 8 tails
</pre>

<ol>
  <li> <p>What would an analogous program to simulate the repeated rolling of a die look like?</p>
  <li> <p>What could be a sample output of this program?</p>
</ol>
 <li> <p>If you were given a string, say &quot;hippopotamus&quot;, and you had to select a random letter, how would you do this?</p>
 <li> <p>If you have to pick a random number between 2 numbers, say <i>i</i> and <i>j</i> (inclusive), how would you do this? (Assume <i>i&lt;j</i>.)</p>
</ol>

<p><small>[<a id="q1a" href="##" onclick="toggleVisible('q1')">show answer</a>]</small></p>
<div id="q1" style="color:#000099;display:none">
<ol type="a">
<li> There are 6 outcomes of dice rolling: the numbers 1 to 6.
<ul>
<li>So we'll need a fixed array <i>count[0..5]</i> of length 6 to count how many of each.</li>
<li>This needs to be initialised to all zeros.</li>
</ul>
</p>
We roll the die <i>NROLLS</i> times, just like we tossed the coin.</li>
<ul>
<li>The outcome each time will be <i>roll = 1 + random()%6</i> .</li>
<li>This is a number between 1 and 6. (<i>Easy to see?</i>)</li>
</ul>
</p>
We increment the count for this <i>roll</i>:
<ul>
<li><i>count[roll-1]++</i></li>
</ul>
</p>
We conclude by printing the contents of the <i>count</i> array.</p>

Output such as the following would be possible (for 20 rolls of the die):
  <pre>
25426251423232651155
Counts = {3,6,2,2,5,2}
</pre>
<ul>
<li>The list of digits shows the sequence of numbers that are rolled.</li>
<li>The count shows how often each number 1, 2, &hellip;, 6 appeared.</li>
</ul>

<li>
<p>
We pick a random number between 0 and 11 (as there are 12 letters in the given string, and they will be stored at indices 0 .. 11), and then print that element in the character array.</p>
   <pre class="answer">
srandom(time(NULL));             // an arbitrary seed
char *string = &quot;hippopotamus&quot;;
int size = strlen(string);
int ran = random() % size;       // 0 &le; ran &le; size-1
printf(&quot;%c\n&quot;, string[ran]);
</pre>

 <li> <p>We pick a random number between 0 and <i>j-i</i>, and add that number to <i>i</i>. Note that we must compute <i>random()</i> modulo (<i>j-i+1</i>) because the number <i>j-i</i> should be included.</p>
    <pre class="answer">
srandom(time(NULL));             // an arbitrary seed
int ran = random()%(j-i+1);      // 0 &le; ran &le; j-i
int num = i + ran;               // i &le; num &le; j
printf(&quot;%d\n&quot;, num);
</pre>
</div>
</li>

<br><li> (Splay trees)

<ol type="a">
<li>
<p> Show how a Splay tree would be constructed if the following values were inserted
into an initially empty tree in the order given:
</p>
<pre>
5 3 8 7 4
</pre>
</li>

<li>
<p> Let <tt>t</tt> be your answer to question a., and consider the following sequence of operations:
<pre>
SearchSplay(t,7);
<del>SearchSplay(t,3);</del>
SearchSplay(t,8);
SearchSplay(t,6);
</pre>
<p>
Show the tree after each operation.
</p>
</li>
</ol>
<p><small>[<a id="q2a" href="##" onclick="toggleVisible('q2')">show answer</a>]</small></p>
<div id="q2" style="color:#000099;display:none">
<ol type="a">
<li>
<p>
The following diagram shows how the tree grows based on the pseudocode given in the lecture:
</p>
<center><img src="Pic/splay-tree.png"></center>
<p>
This is how the tree would grow if root-root rotation were used for the left-left-child and right-right-child cases, as in the standard implementation of Splay trees:
</p>
<center><img src="Pic/splay-tree-a.png"></center>
<p>
</li>
<li>
<p>
The following diagram shows how the tree changes with each search operation:
</p>
<center><img src="Pic/splay-tree2.png"></center>
</ul>
</div>
</li>

<br><li> (AVL trees)

<p>
Answer the following question without the help of the <tt>treeLab</tt> program from the lecture.
</p>

<p> Show how an AVL tree would be constructed if the following values were inserted
into an initially empty tree in the order given:
</p>
<pre>
12 10 8 6 4 2
</pre>

<p><small>[<a id="q3a" href="##" onclick="toggleVisible('q3')">show answer</a>]</small></p>
<div id="q3" style="color:#000099;display:none">
<p>
The following diagram shows how the tree grows:
</p>
<center><img src="Pic/avl-tree.png"></center>
<p>
</div>
</li>

<br><li> (2-3-4 trees)

<p>
Show how a 2-3-4 tree would be constructed if the following values were inserted
into an initially empty tree in the order given:
</p>
<pre>
1 2 3 4 5 8 6 7 9 10
</pre>
<p>
Once you have built the tree, count the number of comparisons needed to search for each of the following values in the tree:
</p>
<pre>
1  7  9  13
</pre>

<p><small>[<a id="q4a" href="##" onclick="toggleVisible('q4')">show answer</a>]</small></p>
<div id="q4" style="color:#000099;display:none">
<p>
The following diagram shows how the tree grows:
</p>
<center><img src="Pic/234-tree.png"></center>
<p>
Search costs (for tree after insertion of 10):
</p>
<p>
<ul>
<li> search(1): cmp(4),cmp(2),cmp(1) &nbsp;&rArr; cost = 3
<li> search(7): cmp(4),cmp(6),cmp(8),cmp(7) &nbsp;&rArr; cost = 4
<li> search(9): cmp(4),cmp(6),cmp(8),cmp(9) &nbsp;&rArr; cost = 4
<li> search(13): cmp(4),cmp(6),cmp(8),cmp(9),cmp(10) &nbsp;&rArr; cost = 5
</ul>
</p>
</div>
</li>

<!--
<br><li> (Red-black trees)

<ol type="a">
<li>
<p>
Show how a red-black tree would be constructed if the following values were inserted
into an initially empty tree in the order given:
</p>
<pre>
1 2 3 4 5 8 6 7 9 10
</pre>
<p>
Once you have built the tree, compute the cost (#comparisons) of searching for
each of the following values in the tree:
</p>
<pre>
1  7  9  13
</pre>
</li>


<li>
<p>
Consider the following high-level description of an algorithm for inserting items into a red-black tree:
</p>
<pre>
insertRB(tree,item,inRight):
   <b>if</b> tree is empty <b>then</b>
      <b>return</b> newNode(item)
   <b>end if</b>
   <b>if</b> left(tree) and right(tree) are <red>RED</red> <b>then</b>
      <i>split 4-node</i>
   <b>end if</b>
   <i>recursive insert cases</i>
   <i>re-arrange links/colours after insert</i>
   <b>return</b> modified tree

insertRedBlack(tree,item):
   tree=insertRB(tree,item,false)
   colour(tree)=BLACK
   <b>return</b> tree
</pre>
<p>
Implement this algorithm in the Red-Black Tree ADT (<a href="https://www.cse.unsw.edu.au/~cs9024/19t0/slides/week06b/progs/RBTree.h"><tt>RBTree.h</tt></a>, <a href="https://www.cse.unsw.edu.au/~cs9024/19t0/slides/week06b/progs/RBTree.c"><tt>RBTree.c</tt></a>) from the lecture as the function:
</p>
<pre>
Tree TreeInsert(Tree t, Item it) { ... }
</pre>
</li>
</ol>
<p>
<i>We have created a script that can automatically test your program. To run this test you can execute the </i><tt>dryrun</tt><i> program that corresponds to the problem set and week. It expects to find a file named </i><tt>RBTree.c</tt><i> in the current directory. You can use dryrun as follows:</i></p>
<pre class="command_line">
<kbd class="shell">~cs9024/bin/dryrun prob06b</kbd>
</pre>
</p>


<p><small>[<a id="q5a" href="##" onclick="toggleVisible('q5')">show answer</a>]</small></p>
<div id="q5" style="color:#000099;display:none">
<ol type="a">
<li>
<p>
The following diagrams shows how the tree grows:
</p>
<center><img src="Pic/rb-tree.png"></center>
<p>
Search costs: The number of comparisons needed to search for a node is 1 + the level of the node in the final red-black tree:
<center><img src="Pic/rb-tree-final.png"></center>
<ul>
<li> search(1): cost = 3
<li> search(7): cost = 4
<li> search(9): cost = 4
<li> search(13): cost = 5
</ul>
<p>
Note that the resulting red-black tree corresponds to the 2-3-4 tree in exercise 4, with identical search costs.
</p>
</li>

<li>
<pre class="answer">
Tree insertRB(Tree t, Item it, bool inRight) {
   if (t == NULL)
      return newNode(it);
   if ( it == data(t) )
      return t;
   if ( isRed(left(t)) && isRed(right(t)) ) {
      colour(t) = RED;
      colour(left(t)) = BLACK;
      colour(right(t)) = BLACK;
   }
   if (it < data(t)) {
      left(t) = insertRB(left(t), it, false);
      if (isRed(t) && isRed(left(t)) && inRight) {
         t = rotateRight(t);
      }
      if ( isRed(left(t)) && isRed(left(left(t))) ) {
         t = rotateRight(t);
         colour(t) = BLACK;
         colour(right(t)) = RED;
      }
   } else {
      right(t) = insertRB(right(t), it, true);
      if ( isRed(t) && isRed(right(t)) && !inRight) {
         t = rotateLeft(t);
      }
      if ( isRed(right(t)) && isRed(right(right(t))) ) { 
         t = rotateLeft(t);
         colour(t) = BLACK;
         colour(left(t)) = RED;
      }
   }
   return t;
}

Tree TreeInsert(Tree t, Item it) {
   t = insertRB(t, it, false);
   colour(t) = BLACK;
   return t;
}
</pre>
</li>
</ol>
</div>
</li>


-->

<br>
<li><b>Challenge Exercise</b>
<p>
Extend the BSTree ADT from the lecture (<a href="https://www.cse.unsw.edu.au/~cs9024/19t0/slides/week06b/progs/BSTree.h"><tt>BSTree.h</tt></a>, <a href="https://www.cse.unsw.edu.au/~cs9024/19t0/slides/week06b/progs/BSTree.c"><tt>BSTree.c</tt></a>) by an implementation of the function
</p>
<pre>
deleteAVL(Tree t, Item it)
</pre>
<p>
to delete an element from an AVL tree while maintaining balance.
</p>
<p><small>[<a id="q6a" href="##" onclick="toggleVisible('q6')">show answer</a>]</small></p>
<div id="q6" style="color:#000099;display:none">
<pre class="answer">
Tree AVLrepair(Tree t) {
   int hL = TreeHeight(left(t));
   int hR = TreeHeight(right(t));
   if ((hL - hR) > 1)
      t = rotateRight(t);
   else if ((hR - hL) > 1)
      t = rotateLeft(t);
   return t;
}

Tree deleteAVL(Tree t, Item it) {
   if (t != NULL) {
      if (it < data(t)) {
         left(t) = TreeDelete(left(t), it);
	 t = AVLrepair(t);
      } else if (it > data(t)) {
         right(t) = TreeDelete(right(t), it);
	 t = AVLrepair(t);
      } else {
         Tree new;
         if (left(t) == NULL && right(t) == NULL)
            new = NULL;
         else if (left(t) == NULL)    // if only right subtree, make it the new root             
            new = right(t);
         else if (right(t) == NULL)   // if only left subtree, make it the new root              
            new = left(t);
         else {                       // left(t) != NULL and right(t) != NULL                    
            new = joinTrees(left(t), right(t));
	    t = AVLrepair(new);
	 }
         free(t);
         t = new;
      }
   }
   return t;
}
</pre>
</div>
</li>

</ol>

</body>
</html>
